--
-- PostgreSQL database dump
--

-- Started on 2013-03-27 15:47:41 ART

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;

CREATE DATABASE openpacs WITH TEMPLATE = template0 ENCODING = 'UTF8' LC_COLLATE = 'C' LC_CTYPE = 'C';

\connect openpacs

--
-- TOC entry 618 (class 2612 OID 23958)
-- Name: plpgsql; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: postgres
--

CREATE PROCEDURAL LANGUAGE plpgsql;


ALTER PROCEDURAL LANGUAGE plpgsql OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- TOC entry 503 (class 1247 OID 68857)
-- Dependencies: 3 142
-- Name: imagetosend; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE imagetosend AS (
	idimage integer,
	idstudy integer,
	idseries integer,
	imagepath character varying
);


ALTER TYPE public.imagetosend OWNER TO postgres;

--
-- TOC entry 500 (class 1247 OID 68854)
-- Dependencies: 3 141
-- Name: routingtaskstoexecute; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE routingtaskstoexecute AS (
	destinationtype character varying,
	aesource character varying,
	destinationfolder character varying,
	filterattribute character varying,
	filtervalue character varying,
	idrule integer,
	ip character varying,
	port integer,
	aetitle character varying,
	minuto character varying,
	hora character varying,
	dia character varying,
	mes character varying,
	diasemana character varying
);


ALTER TYPE public.routingtaskstoexecute OWNER TO postgres;

--
-- TOC entry 497 (class 1247 OID 68846)
-- Dependencies: 3
-- Name: status_; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE status_ AS ENUM (
    'scheduled',
    'completed',
    'dictated',
    'cancelled',
    'finalized'
);


ALTER TYPE public.status_ OWNER TO postgres;

--
-- TOC entry 206 (class 1255 OID 69094)
-- Dependencies: 3 618
-- Name: amrouting(character varying, character varying, character varying, character varying, character varying, character varying, integer, character varying, boolean, boolean, integer, integer, integer, boolean, boolean, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION amrouting(dd character varying, hh character varying, mm character varying, aesour character varying, filterattr character varying, filterval character varying, idaedest integer, destfolder character varying, delafter boolean, getprevstudies boolean, qprevstudies integer, wtime integer, priority integer, enatask boolean, enarule boolean, idr integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
		res int;
  BEGIN
		
		if idr isnull then
		  insert into routingschedulingtask (idscheduling,dia, hora, minuto) values (nextval('routingschedulingtask_idscheduling_seq'),dd,hh,mm);
		  res=currval('routingschedulingtask_idscheduling_seq');
		  insert into routingrules (aesource, filterattribute, filtervalue, idaedestination, destinationfolder, deleteafter, getpreviousstudies, 
      quantitypreviousstudies, waittime, prioritysequence,enabletask,enablerule,idscheduling) values 
      ( aesour, filterattr, filterval, idaedest,  
      destfolder, delafter,getprevstudies, qprevstudies,wtime,priority ,enaTask,enarule, res);
		else
      select into res idscheduling from routingrules where idrule=idr;
		  update routingschedulingtask set dia=dd, hora=hh, minuto=mm
		  where idscheduling=res;

		  update routingrules SET aesource=aesour , filterattribute=filterattr, filtervalue=filterval, 
		  idaedestination=idaedest, destinationfolder= destfolder, deleteafter=delafter, 
		  getpreviousstudies=getprevstudies, quantitypreviousstudies=qprevstudies, waittime=wtime,prioritysequence=priority, enabletask=enatask,enablerule=enarule,
		  idscheduling= res where idrule=idr;
		  
		end if;
		
		RETURN res;
  END;
$$;


ALTER FUNCTION public.amrouting(dd character varying, hh character varying, mm character varying, aesour character varying, filterattr character varying, filterval character varying, idaedest integer, destfolder character varying, delafter boolean, getprevstudies boolean, qprevstudies integer, wtime integer, priority integer, enatask boolean, enarule boolean, idr integer) OWNER TO postgres;

--
-- TOC entry 212 (class 1255 OID 124670)
-- Dependencies: 618 3
-- Name: avellaneda_migration(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION avellaneda_migration() RETURNS character varying
    LANGUAGE plpgsql
    AS $$

declare RPImages record;
declare RStudy record;

begin

  for RPImages in ( 
select i.idimage,st.idstudy,se.idseries,i.imagepath from image i
join series se on i.idseries=se.idseries
join study st on se.idstudy=st.idstudy
join patient p on st.idpatient = p.idpatient
where st.institutionname like '%AVELLANEDA%' and age(now(),studydate) < interval '6 mons'
order by studydate desc
                   )
                   LOOP
                   INSERT INTO routingtasks(idimage,idstudy,idserie,idrule,pathimage,aetdest,ipaddressdest,portdest,pathdest,prestudiesnumber,"minute","hour","day",status,creationdate,starteddate,finisheddate,intentos)
                   values(RPImages.idimage,RPImages.idstudy,RPImages.idseries,'1',RPImages.imagepath,'DCMQRSCP','172.16.1.102','104','',null,'*','*','*','programada',CURRENT_TIMESTAMP,null,null,'0');
                   END LOOP; 
		   return 'DONE';  
                  end;
                 
$$;


ALTER FUNCTION public.avellaneda_migration() OWNER TO postgres;

--
-- TOC entry 208 (class 1255 OID 113881)
-- Dependencies: 618 3
-- Name: clean_patient_records_withnone_image(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION clean_patient_records_withnone_image() RETURNS character varying
    LANGUAGE plpgsql
    AS $$

declare RPatient record;
declare RStudy record;
declare RSeries record;
begin

  delete from image where idseries not in (select idseries from series);
  delete from series where idseries not in (select idseries from image);
  delete from series where idstudy not in (select idstudy from study);
  delete from study where idstudy not in (select idstudy from series);
  --delete from patient where idpatient not in (select idpatient from study);
  --delete from patient where idpatient not in (select idpatient from study) and patientname like '%|%' and patientname not like '%null%';
  for RPatient in ( 
		    select p.idpatient from patient p 
		    join study st on p.idpatient=st.idpatient
                    join series s on st.idstudy=s.idstudy
                    where s.idseries not in
                    (
                     select idseries from image
                    )
                     and p.patientid like '%null%'
                   ) 
  LOOP
		for RStudy in (select st.idstudy from study st where st.idpatient=RPatient.idpatient) 
		LOOP
			for RSeries in (select s.idseries from series s where s.idstudy=RStudy.idstudy)
			LOOP
			delete from series where idseries=RSeries.idseries;
			END LOOP;
                delete from study where idstudy=RStudy.idstudy;	
		END LOOP;
  delete from patient where idpatient=RPatient.idpatient; 
  END LOOP;
    return 'DONE';    
end;
$$;


ALTER FUNCTION public.clean_patient_records_withnone_image() OWNER TO postgres;

--
-- TOC entry 211 (class 1255 OID 113879)
-- Dependencies: 3 618
-- Name: clean_patient_records_withnone_study_series(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION clean_patient_records_withnone_study_series() RETURNS character varying
    LANGUAGE plpgsql
    AS $$

declare RPatient record;
declare RStudy record;
declare RSeries record;
begin
  delete from image where idseries not in (select idseries from series);
  delete from series where idseries not in (select idseries from image);
  delete from series where idstudy not in (select idstudy from study);
  delete from study where idstudy not in (select idstudy from series);
  --delete from patient where idpatient not in (select idpatient from study);
  --delete from patient where idpatient not in (select idpatient from study) and patientname like '%|%' and patientname not like '%null%';

  for RPatient in (
                   select p.idpatient from patient p 
		   where p.idpatient not in
                   (
                    select idpatient from study
                   ) 
                   and patientid like '%null%'                    
                  ) 
  LOOP
		for RStudy in (select st.idstudy from study st where st.idpatient=RPatient.idpatient) 
		LOOP
			for RSeries in (select s.idseries from series s where s.idstudy=RStudy.idstudy)
			LOOP
			delete from series where idseries=RSeries.idseries;
			END LOOP;
                delete from study where idstudy=RStudy.idstudy;	
		END LOOP;
  delete from patient where idpatient=RPatient.idpatient; 
  END LOOP;
    return 'DONE';    
end;
$$;


ALTER FUNCTION public.clean_patient_records_withnone_study_series() OWNER TO postgres;

--
-- TOC entry 207 (class 1255 OID 69097)
-- Dependencies: 3 618
-- Name: drouting(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION drouting(idr integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
		_idscheduling int;
  BEGIN
		
		if not idr isnull then		  
		  select t.idscheduling into _idscheduling from routingrules t where idrule=idr; 
      if not _idscheduling isnull then
        delete from routingrules where idrule=idr;
        delete from routingschedulingtask where idscheduling=_idscheduling;
      end if;
		  		
		end if;
		
		RETURN _idscheduling;
  END;
$$;


ALTER FUNCTION public.drouting(idr integer) OWNER TO postgres;

--
-- TOC entry 202 (class 1255 OID 124660)
-- Dependencies: 618 3
-- Name: formigration(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION formigration() RETURNS character varying
    LANGUAGE plpgsql
    AS $$

declare RPImages record;
declare RStudy record;

begin

  for RPImages in ( 
select * from image i
join series se on i.idseries=se.idseries
join study st on se.idstudy=st.idstudy
where st.institutionname ='DOMINIS'
                   )
                   LOOP
                   INSERT INTO routingtasks(idimage,idstudy,idserie,idrule,pathimage,aetdest,ipaddressdest,portdest,pathdest,prestudiesnumber,"minute","hour","day",status,creationdate,starteddate,finisheddate,intentos,tracked)
                   values(RPImages.idimage,RPImages.idstudy,RPImages.idseries,'1',RPImages.imagepath,'DCMQRSCP','192.168.0.106','104','',null,'*','*','*','programada',CURRENT_TIMESTAMP,null,null,'0',false);
                   END LOOP; 
		   return 'DONE';  
                  end;
                 
$$;


ALTER FUNCTION public.formigration() OWNER TO postgres;

--
-- TOC entry 200 (class 1255 OID 69098)
-- Dependencies: 3 618
-- Name: newitemtaskmanager(integer, character varying, character varying, character varying, character varying, boolean, character varying, boolean, character varying, integer, integer, character varying, character varying, character varying, integer, integer, integer, boolean, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION newitemtaskmanager(iduser_ integer, taskname_ character varying, description_ character varying, operationtype_ character varying, relatedtable_ character varying, trakingenabled_ boolean, status_ character varying, expiredtask_ boolean, executiontype_ character varying, executionhour_ integer, executionminute_ integer, executiontypehour_ character varying, executiondays_ character varying, executiontime_ character varying, amount_ integer, done_ integer, remaining_ integer, isrunning_ boolean, tagfilter_ character varying, tagvalue_ character varying, statustudy_ character varying, daysantiquity_ integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	id_taskmanager_ integer;
        lTagFilter character varying;
        lTagValue character varying;
        lStatusStudy character varying;
        lDaysAntiquity integer;

BEGIN
	id_taskmanager_=0;
	lTagFilter=tagfilter_;
	lTagValue=tagvalue_;
	lStatusStudy= statustudy_;
	lDaysAntiquity=daysantiquity_;
	
	select into id_taskmanager_ nextval('taskmanager_idtaskmanager_seq');
	insert into taskmanager(idtaskmanager,iduser,taskname,description,
		    		operationtype,relatedtable,trakingenabled,
		    		status,expiredtask,executiontype,executionhour,
  		    		executionminute,executiontypehour,executiondays,
		    		executiontime,amount,done,remaining,isrunning)
	     		 values(id_taskmanager_,
                    		iduser_,taskname_,description_,operationtype_,relatedtable_,trakingenabled_,status_,
                    		expiredtask_,executiontype_,executionhour_,executionminute_,executiontypehour_,
				executiondays_,executiontime_,amount_,done_,remaining_,isrunning_);
	--if(relatedtable_='taskscleaning') THEN
	

	Insert into taskscleaning 
			 values(nextval('taskscleaning_idcleaningtask_seq'),id_taskmanager_,lTagFilter,
				lTagValue,lStatusStudy,lDaysAntiquity); 				
RETURN id_taskmanager_; 
END;

$$;


ALTER FUNCTION public.newitemtaskmanager(iduser_ integer, taskname_ character varying, description_ character varying, operationtype_ character varying, relatedtable_ character varying, trakingenabled_ boolean, status_ character varying, expiredtask_ boolean, executiontype_ character varying, executionhour_ integer, executionminute_ integer, executiontypehour_ character varying, executiondays_ character varying, executiontime_ character varying, amount_ integer, done_ integer, remaining_ integer, isrunning_ boolean, tagfilter_ character varying, tagvalue_ character varying, statustudy_ character varying, daysantiquity_ integer) OWNER TO postgres;

--
-- TOC entry 210 (class 1255 OID 122201)
-- Dependencies: 3 618
-- Name: storeimage(date, time without time zone, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, date, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, date, time without time zone, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying, character varying, character varying, character varying, date, time without time zone, date, time without time zone, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION storeimage(patientbirthdate_ date, patientbirthtime_ time without time zone, patientsex_ character varying, patientname_ character varying, patientid_ character varying, otherpatientids_ character varying, otherpatientnames_ character varying, ethnicgroup_ character varying, patientage_ character varying, patientsize_ character varying, patientweight_ character varying, occupation_ character varying, studydate_ date, studytime_ character varying, studyid_ character varying, studydescription_ character varying, institutionname_ character varying, modality_ character varying, modalityaetitle_ character varying, nameofphysiciansreadingstudy_ character varying, accessionnumber_ character varying, referringphysiciansname_ character varying, studyinstanceuid_ character varying, seriesnumber_ character varying, seriesinstanceuid_ character varying, sopinstanceuid_ character varying, seriesdate_ date, seriestime_ time without time zone, seriesdescription_ character varying, bodypartexamined_ character varying, protocolname_ character varying, operatorsname_ character varying, performingphysiciansname_ character varying, rows_ integer, columns_ integer, filesizebytes_ integer, contentlabel_ character varying, instancenumber_ character varying, imagetype_ character varying, sopclassuid_ character varying, acquisitiondate_ date, acquisitiontime_ time without time zone, contentdate_ date, contenttime_ time without time zone, acquisitionnumber_ character varying, acr_nema_imageposition_ character varying, imagepositionpatient_ character varying, imageorientationpatient_ character varying, frameofreferenceuid_ character varying, slicelocation_ character varying, numberofframes_ character varying, image_ character varying, patientposition_ character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  FunctResult varchar(255);
  IdPatient_ integer;
  lPatientId varchar(255);
  lPostPatientId varchar(255); 
  a integer;
  lPatientName varchar(255);
  lSeqPatientId integer;
  lIdPatientExist integer;
  IdStudy_ Integer;
  IdSeries_ Integer;
  IdImage_ integer;
  OLDImage_ varchar(255);
  study_time time without time zone;
BEGIN

  if( studytime_='') then
  study_time = now()::time;
  else
  study_time=studytime_;
  end if;
  -- Inserta paciente
  -- select IdPatient from patient 
  -- where PatientID=PatientID_ into IdPatient_;
  RAISE NOTICE '------Starting Patient section---------';
   
  if (PatientID_='') then
  RAISE NOTICE 'Parameter patientid was not provided';
     select nextval('public."patient_patientid_seq"') into a;
     select currval('public."patient_patientid_seq"') into lSeqPatientId;
     lPatientID=lSeqPatientId||'|'||'null' ||'|' || ModalityAetitle_;        
     RAISE NOTICE 'New patientid autogenerated [%]',lPatientID;
  else
  RAISE NOTICE 'Parameter PatientID provided [%] ',PatientID_;
     lPatientID=PatientID_;
  end if;  

  RAISE NOTICE 'Searching patient with PatientID [%]',lPatientID;
  select into IdPatient_,lPatientName idpatient,patientname
  from patient
  --where PatientID=PatientID_;
  where PatientID=lPatientID;
  
   
  if(IdPatient_ is null) then
    --values(PatientBirthDate_, PatientBirthTime_, PatientSex_, PatientName_, PatientID_, 
    RAISE NOTICE 'Patient not found. New Patient will be created with patientID [%]',lPatientID;
    insert into patient(
      PatientBirthDate, PatientBirthTime, PatientSex, PatientName, PatientID, 
      OtherPatientIDs, OtherPatientNames, EthnicGroup, PatientAge, PatientSize,
      PatientWeight, Occupation)   
    values(PatientBirthDate_, PatientBirthTime_, PatientSex_, PatientName_, lPatientID, 
      OtherPatientIDs_, OtherPatientNames_, EthnicGroup_, PatientAge_, PatientSize_,
      PatientWeight_, Occupation_);
    IdPatient_ = currval(pg_get_serial_sequence('patient', 'idpatient'));
  else
     if (lPatientName=patientname_) then
       RAISE NOTICE 'Patient [%] found. Updating patient info: [%]',lPatientName,lPatientID;
       UPDATE patient
       SET patientbirthdate=PatientBirthDate_, patientbirthtime=PatientBirthTime_, patientsex=PatientSex_, 
       patientname=PatientName_, otherpatientids=OtherPatientIDs_, otherpatientnames=OtherPatientNames_, 
       ethnicgroup= EthnicGroup_, patientage=PatientAge_, patientsize=PatientSize_, patientweight=PatientWeight_, 
       occupation=Occupation_
       --where PatientID=PatientID_;
         where PatientID=lPatientID;    
    else
          -- Se cambia el IdPatient.
          -- PIW= Patient Identification Warning
	  --lPostPatientId=PatientID_||'|'|| ModalityAetitle_||'|'||studyinstanceuid_;
       RAISE NOTICE 'Patient found, but patientname seems to be differents: PatientName found: [%] Paramater PatientName [%] ',lPatientName,PatientName_;
       select nextval('public."patient_patientid_seq"') into a;
       select currval('public."patient_patientid_seq"') into lSeqPatientId;
       lPostPatientId=lPatientID||'|'|| ModalityAetitle_||'|'||studyinstanceuid_;      
       lPatientId=lSeqPatientId||'|'||lPostPatientId;
       RAISE NOTICE 'Two new patientid will be generated';
       RAISE NOTICE '[%] ',lPostPatientId;          
       RAISE NOTICE '[%]',lPatientId;
       select idpatient from patient where patientid like '%'||lPostPatientId limit 1 into  lIdPatientExist;
       
         if (lIdPatientExist is null) then
         RAISE NOTICE 'No idpatient was found with patientid [%]',lPostPatientId;
         RAISE NOTICE 'Creating new patient info with patientid [%]',lPostPatientId;
            insert into patient(
            PatientBirthDate, PatientBirthTime, PatientSex, PatientName, PatientID, 
            OtherPatientIDs, OtherPatientNames, EthnicGroup, PatientAge, PatientSize,
            PatientWeight, Occupation)
            values(PatientBirthDate_, PatientBirthTime_, PatientSex_, PatientName_, lPatientId, 
            lIdPatientExist, OtherPatientNames_, EthnicGroup_, PatientAge_, PatientSize_,
            PatientWeight_, Occupation_);
            IdPatient_ = currval(pg_get_serial_sequence('patient', 'idpatient'));           
         else
         RAISE NOTICE 'Updating patient info. Idpatient [%] found with patientid [%]',lIdPatientExist,lPostPatientId;
            IdPatient_=lIdPatientExist;	
	 end if;
          --IdPatient_ = currval(pg_get_serial_sequence('patient', 'idpatient')); 		
    end if;      
  end if;




  RAISE NOTICE '------Starting Study section---------';
   -- Inserta el estudio
  select IdStudy from study
    where (StudyInstanceUID = StudyInstanceUID_) 
  into IdStudy_;
  
  if(IdStudy_ is null) then
  RAISE NOTICE 'idstudy not found with StudyInstanceUID [%]',StudyInstanceUID_;
  RAISE NOTICE 'Creating study [%]',StudyInstanceUID_;
    insert into study(
      StudyDate, StudyTime, StudyId, StudyDescription, Modality,ModalityAetitle,  
      NameOfPhysiciansReadingStudy, AccessionNumber,
      PerformingPhysiciansName, ReferringPhysiciansName, StudyInstanceUID, Status, IdPatient, InstitutionName,created_time)
    values(StudyDate_, study_time, StudyId_, StudyDescription_, Modality_,ModalityAetitle_,  
    NameOfPhysiciansReadingStudy_, AccessionNumber_,
      PerformingPhysiciansName_,ReferringPhysiciansName_,StudyInstanceUID_,
      'completed', IdPatient_, -- Al recibir una imágen siempre el estado es completed
      InstitutionName_,now()
      );   
     IdStudy_ = currval(pg_get_serial_sequence('study', 'idstudy'));
   else
   RAISE NOTICE 'Updating study info. Idstudy [%] found with StudyInstanceUID [%]',IdStudy_,StudyInstanceUID_;
     UPDATE study
  SET  studydate=StudyDate_, studytime=study_time, studydescription=StudyDescription_, 
       modality=Modality_,ModalityAetitle=ModalityAetitle_, nameofphysiciansreadingstudy=NameOfPhysiciansReadingStudy_, accessionnumber=AccessionNumber_, 
       performingphysiciansname=PerformingPhysiciansName_, referringphysiciansname=ReferringPhysiciansName_,
       studyinstanceuid=StudyInstanceUID, status='completed',idpatient=IdPatient_, institutionname=InstitutionName_,created_time=now()
       where IdStudy = IdStudy_;   
   end if;


 RAISE NOTICE '------Starting Serie section---------';
   -- Inserta la serie
   select IdSeries from series
     where SeriesInstanceUID=SeriesInstanceUID_ into IdSeries_;
   if(IdSeries_ is null) then
   RAISE NOTICE 'idseries not found with SeriesInstanceUID [%]',StudyInstanceUID_;
   RAISE NOTICE 'Creating new serie [%]',SeriesInstanceUID_;
     insert into series(
       SeriesNumber, SeriesInstanceUID, SeriesDate,
       SeriesTime, SeriesDescription, BodyPartExamined, ProtocolName,
       OperatorsName,
       ContentLabel, IdStudy) 
     values(SeriesNumber_, SeriesInstanceUID_, SeriesDate_,
       SeriesTime_, SeriesDescription_, BodyPartExamined_,ProtocolName_,
       OperatorsName_,
       ContentLabel_,
       IdStudy_);
     IdSeries_ = currval(pg_get_serial_sequence('series', 'idseries'));
     else
      RAISE NOTICE 'Updating series info.Idseries [%] found with SeriesInstanceUID [%]',IdSeries_,SeriesInstanceUID_;
     UPDATE series
   SET seriesnumber=SeriesNumber_,seriesdate=SeriesDate_, 
       seriestime=SeriesTime_, seriesdescription=SeriesDescription_, bodypartexamined=BodyPartExamined_,
       protocolname=ProtocolName_, operatorsname=OperatorsName_, contentlabel=ContentLabel_,
       idstudy=IdStudy_
       where SeriesInstanceUID=SeriesInstanceUID_; 
   end if;

   

 RAISE NOTICE '------Starting Image section---------';
  select IdImage from image
    where (sopinstanceuid = sopinstanceuid_) 
  into IdImage_;

  if (IdImage_ is null) then
   -- Inserta la imagen
   RAISE NOTICE 'idimage not found with sopinstanceuid [%]',sopinstanceuid_;
   RAISE NOTICE 'Creating new image [%]',sopinstanceuid_;
  insert into image(ImagePath,ThumbnailPath,SOPInstanceUID,IdSeries,Rows,
    Columns,FileSizeBytes,DateCreated,
    InstanceNumber, ImageType, SOPClassUID,
    AcquisitionDate, AcquisitionTime, ContentDate, ContentTime,
    AcquisitionNumber, Acr_Nema_ImagePosition,
    ImagePositionPatient, ImageOrientationPatient,
    FrameOfReferenceUID, SliceLocation,  NumberOfFrames, PatientPosition,status 
    ) 
  values(Image_, Image_||'.jpg', SOPInstanceUID_, IdSeries_, Rows_, 
    Columns_, FileSizeBytes_, current_timestamp, 
    InstanceNumber_, ImageType_, SOPClassUID_,
    AcquisitionDate_, AcquisitionTime_, ContentDate_, ContentTime_,
    AcquisitionNumber_, Acr_Nema_ImagePosition_,
    ImagePositionPatient_, ImageOrientationPatient_,
    FrameOfReferenceUID_, SliceLocation_,  NumberOfFrames_, PatientPosition_,'existing'
    );
    else
    RAISE NOTICE 'Updating image info. Idimage [%] found with sopinstanceuid [%]',IdImage_,sopinstanceuid_;
    UPDATE image
    SET ImagePath=Image_, ThumbnailPath=Image_||'.jpg',SOPInstanceUID=SOPInstanceUID_,IdSeries=IdSeries_, Rows=Rows_,
    Columns=Columns_, FileSizeBytes=FileSizeBytes_, DateCreated=current_timestamp,
    InstanceNumber=InstanceNumber_, AcquisitionTime=AcquisitionTime_,ContentDate=ContentDate_, ContentTime=ContentTime_,
    AcquisitionNumber=AcquisitionNumber_, Acr_Nema_ImagePosition=Acr_Nema_ImagePosition_,
    ImagePositionPatient=ImagePositionPatient_, ImageOrientationPatient=ImageOrientationPatient_,
    FrameOfReferenceUID=FrameOfReferenceUID_, SliceLocation=SliceLocation_,  NumberOfFrames=NumberOfFrames_, PatientPosition=PatientPosition_,status='existing'
    where sopinstanceuid = sopinstanceuid_  ; 
   end if;

  RAISE NOTICE 'Leaving PSQL procedure... ';
  FunctResult='DONE';
  RETURN FunctResult;    

  --EXCEPTION WHEN SQLSTATE '22001' THEN
  --RAISE NOTICE 'SQl error';
  
  EXCEPTION WHEN OTHERS THEN   
  begin
  RAISE NOTICE '-------SQL ERROR ---------';  
  RAISE NOTICE 'SQLState    [%],', SQLSTATE;
  RAISE NOTICE 'SQL Message [%],',SQLERRM;
  RAISE NOTICE '-------SQL ERROR ---------';
  RETURN 'ERROR '|| SQLSTATE ||' '||SQLERRM;
  end;
END;
$$;


ALTER FUNCTION public.storeimage(patientbirthdate_ date, patientbirthtime_ time without time zone, patientsex_ character varying, patientname_ character varying, patientid_ character varying, otherpatientids_ character varying, otherpatientnames_ character varying, ethnicgroup_ character varying, patientage_ character varying, patientsize_ character varying, patientweight_ character varying, occupation_ character varying, studydate_ date, studytime_ character varying, studyid_ character varying, studydescription_ character varying, institutionname_ character varying, modality_ character varying, modalityaetitle_ character varying, nameofphysiciansreadingstudy_ character varying, accessionnumber_ character varying, referringphysiciansname_ character varying, studyinstanceuid_ character varying, seriesnumber_ character varying, seriesinstanceuid_ character varying, sopinstanceuid_ character varying, seriesdate_ date, seriestime_ time without time zone, seriesdescription_ character varying, bodypartexamined_ character varying, protocolname_ character varying, operatorsname_ character varying, performingphysiciansname_ character varying, rows_ integer, columns_ integer, filesizebytes_ integer, contentlabel_ character varying, instancenumber_ character varying, imagetype_ character varying, sopclassuid_ character varying, acquisitiondate_ date, acquisitiontime_ time without time zone, contentdate_ date, contenttime_ time without time zone, acquisitionnumber_ character varying, acr_nema_imageposition_ character varying, imagepositionpatient_ character varying, imageorientationpatient_ character varying, frameofreferenceuid_ character varying, slicelocation_ character varying, numberofframes_ character varying, image_ character varying, patientposition_ character varying) OWNER TO postgres;

--
-- TOC entry 209 (class 1255 OID 97465)
-- Dependencies: 618 3
-- Name: storeimage_experimental(date, time without time zone, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, date, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, date, time without time zone, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying, character varying, character varying, character varying, date, time without time zone, date, time without time zone, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION storeimage_experimental(patientbirthdate_ date, patientbirthtime_ time without time zone, patientsex_ character varying, patientname_ character varying, patientid_ character varying, otherpatientids_ character varying, otherpatientnames_ character varying, ethnicgroup_ character varying, patientage_ character varying, patientsize_ character varying, patientweight_ character varying, occupation_ character varying, studydate_ date, studytime_ character varying, studyid_ character varying, studydescription_ character varying, institutionname_ character varying, modality_ character varying, modalityaetitle_ character varying, nameofphysiciansreadingstudy_ character varying, accessionnumber_ character varying, referringphysiciansname_ character varying, studyinstanceuid_ character varying, seriesnumber_ character varying, seriesinstanceuid_ character varying, sopinstanceuid_ character varying, seriesdate_ date, seriestime_ time without time zone, seriesdescription_ character varying, bodypartexamined_ character varying, protocolname_ character varying, operatorsname_ character varying, performingphysiciansname_ character varying, rows_ integer, columns_ integer, filesizebytes_ integer, contentlabel_ character varying, instancenumber_ character varying, imagetype_ character varying, sopclassuid_ character varying, acquisitiondate_ date, acquisitiontime_ time without time zone, contentdate_ date, contenttime_ time without time zone, acquisitionnumber_ character varying, acr_nema_imageposition_ character varying, imagepositionpatient_ character varying, imageorientationpatient_ character varying, frameofreferenceuid_ character varying, slicelocation_ character varying, numberofframes_ character varying, image_ character varying, patientposition_ character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  FunctResult varchar(255);
  IdPatient_ integer;
  lPatientId varchar(255);
  lPostPatientId varchar(255); 
  a integer;
  lPatientName varchar(255);
  lSeqPatientId integer;
  lIdPatientExist integer;
  IdStudy_ Integer;
  IdSeries_ Integer;
  IdImage_ integer;
  OLDImage_ varchar(255);
  study_time time without time zone;
BEGIN

  if( studytime_='') then
  study_time = now()::time;
  else
  study_time=studytime_;
  end if;
  -- Inserta paciente
  -- select IdPatient from patient 
  -- where PatientID=PatientID_ into IdPatient_;
  RAISE NOTICE '------Starting Patient section---------';
   
  if (PatientID_='') then
  RAISE NOTICE 'Parameter patientid was not provided';
     select nextval('public."patient_patientid_seq"') into a;
     select currval('public."patient_patientid_seq"') into lSeqPatientId;
     lPatientID=lSeqPatientId||'|'||'null' ||'|' || ModalityAetitle_;        
     RAISE NOTICE 'New patientid autogenerated [%]',lPatientID;
  else
  RAISE NOTICE 'Parameter PatientID provided [%] ',PatientID_;
     lPatientID=PatientID_;
  end if;  

  RAISE NOTICE 'Searching patient with PatientID [%]',lPatientID;
  select into IdPatient_,lPatientName idpatient,patientname
  from patient
  --where PatientID=PatientID_;
  where PatientID=lPatientID;
  
   
  if(IdPatient_ is null) then
    --values(PatientBirthDate_, PatientBirthTime_, PatientSex_, PatientName_, PatientID_, 
    RAISE NOTICE 'Patient not found. New Patient will be created. Autogenerated PatientID: [%]',lPatientID;
    insert into patient(
      PatientBirthDate, PatientBirthTime, PatientSex, PatientName, PatientID, 
      OtherPatientIDs, OtherPatientNames, EthnicGroup, PatientAge, PatientSize,
      PatientWeight, Occupation)   
    values(PatientBirthDate_, PatientBirthTime_, PatientSex_, PatientName_, lPatientID, 
      OtherPatientIDs_, OtherPatientNames_, EthnicGroup_, PatientAge_, PatientSize_,
      PatientWeight_, Occupation_);
    IdPatient_ = currval(pg_get_serial_sequence('patient', 'idpatient'));
  else
     if (lPatientName=patientname_) then
       RAISE NOTICE 'Patient [%] found. Updating patient info: [%]',lPatientName,lPatientID;
       UPDATE patient
       SET patientbirthdate=PatientBirthDate_, patientbirthtime=PatientBirthTime_, patientsex=PatientSex_, 
       patientname=PatientName_, otherpatientids=OtherPatientIDs_, otherpatientnames=OtherPatientNames_, 
       ethnicgroup= EthnicGroup_, patientage=PatientAge_, patientsize=PatientSize_, patientweight=PatientWeight_, 
       occupation=Occupation_
       --where PatientID=PatientID_;
         where PatientID=lPatientID;    
    else
          -- Se cambia el IdPatient.
          -- PIW= Patient Identification Warning
	  --lPostPatientId=PatientID_||'|'|| ModalityAetitle_||'|'||studyinstanceuid_;
       RAISE NOTICE 'Patient found, but patientname seems to be differents: PatientName found: [%] Paramater PatientName [%] ',lPatientName,PatientName_;
       select nextval('public."patient_patientid_seq"') into a;
       select currval('public."patient_patientid_seq"') into lSeqPatientId;
       lPostPatientId=lPatientID||'|'|| ModalityAetitle_||'|'||studyinstanceuid_;      
       lPatientId=lSeqPatientId||'|'||lPostPatientId;
       RAISE NOTICE 'Two new patientid will be generated';
       RAISE NOTICE '[%] ',lPostPatientId;          
       RAISE NOTICE '[%]',lPatientId;
       select idpatient from patient where patientid like '%'||lPostPatientId limit 1 into  lIdPatientExist;
       
         if (lIdPatientExist is null) then
         RAISE NOTICE 'No idpatient was found with patientid [%]',lPostPatientId;
         RAISE NOTICE 'Creating new patient info with patientid [%]',lPostPatientId;
            insert into patient(
            PatientBirthDate, PatientBirthTime, PatientSex, PatientName, PatientID, 
            OtherPatientIDs, OtherPatientNames, EthnicGroup, PatientAge, PatientSize,
            PatientWeight, Occupation)
            values(PatientBirthDate_, PatientBirthTime_, PatientSex_, PatientName_, lPatientId, 
            lIdPatientExist, OtherPatientNames_, EthnicGroup_, PatientAge_, PatientSize_,
            PatientWeight_, Occupation_);
            IdPatient_ = currval(pg_get_serial_sequence('patient', 'idpatient'));           
         else
         RAISE NOTICE 'Updating patient info. Idpatient [%] found with patientid [%]',lIdPatientExist,lPostPatientId;
            IdPatient_=lIdPatientExist;	
	 end if;
          --IdPatient_ = currval(pg_get_serial_sequence('patient', 'idpatient')); 		
    end if;      
  end if;




  RAISE NOTICE '------Starting Study section---------';
   -- Inserta el estudio
  select IdStudy from study
    where (StudyInstanceUID = StudyInstanceUID_) 
  into IdStudy_;
  
  if(IdStudy_ is null) then
  RAISE NOTICE 'idstudy not found with StudyInstanceUID [%]',StudyInstanceUID_;
  RAISE NOTICE 'Creating study [%]',StudyInstanceUID_;
    insert into study(
      StudyDate, StudyTime, StudyId, StudyDescription, Modality,ModalityAetitle,  
      NameOfPhysiciansReadingStudy, AccessionNumber,
      PerformingPhysiciansName, ReferringPhysiciansName, StudyInstanceUID, Status, IdPatient, InstitutionName,created_time)
    values(StudyDate_, study_time, StudyId_, StudyDescription_, Modality_,ModalityAetitle_,  
    NameOfPhysiciansReadingStudy_, AccessionNumber_,
      PerformingPhysiciansName_,ReferringPhysiciansName_,StudyInstanceUID_,
      'completed', IdPatient_, -- Al recibir una imágen siempre el estado es completed
      InstitutionName_,now()
      );   
     IdStudy_ = currval(pg_get_serial_sequence('study', 'idstudy'));
   else
   RAISE NOTICE 'Updating study info. Idstudy [%] found with StudyInstanceUID [%]',IdStudy_,StudyInstanceUID_;
     UPDATE study
  SET  studydate=StudyDate_, studytime=study_time, studydescription=StudyDescription_, 
       modality=Modality_,ModalityAetitle=ModalityAetitle_, nameofphysiciansreadingstudy=NameOfPhysiciansReadingStudy_, accessionnumber=AccessionNumber_, 
       performingphysiciansname=PerformingPhysiciansName_, referringphysiciansname=ReferringPhysiciansName_,
       studyinstanceuid=StudyInstanceUID, status='completed',idpatient=IdPatient_, institutionname=InstitutionName_,created_time=now()
       where IdStudy = IdStudy_;   
   end if;


 RAISE NOTICE '------Starting Serie section---------';
   -- Inserta la serie
   select IdSeries from series
     where SeriesInstanceUID=SeriesInstanceUID_ into IdSeries_;
   if(IdSeries_ is null) then
   RAISE NOTICE 'idseries not found with SeriesInstanceUID [%]',StudyInstanceUID_;
   RAISE NOTICE 'Creating new serie [%]',SeriesInstanceUID_;
     insert into series(
       SeriesNumber, SeriesInstanceUID, SeriesDate,
       SeriesTime, SeriesDescription, BodyPartExamined, ProtocolName,
       OperatorsName,
       ContentLabel, IdStudy) 
     values(SeriesNumber_, SeriesInstanceUID_, SeriesDate_,
       SeriesTime_, SeriesDescription_, BodyPartExamined_,ProtocolName_,
       OperatorsName_,
       ContentLabel_,
       IdStudy_);
     IdSeries_ = currval(pg_get_serial_sequence('series', 'idseries'));
     else
      RAISE NOTICE 'Updating series info.Idseries [%] found with SeriesInstanceUID [%]',IdSeries_,SeriesInstanceUID_;
     UPDATE series
   SET seriesnumber=SeriesNumber_,seriesdate=SeriesDate_, 
       seriestime=SeriesTime_, seriesdescription=SeriesDescription_, bodypartexamined=BodyPartExamined_,
       protocolname=ProtocolName_, operatorsname=OperatorsName_, contentlabel=ContentLabel_,
       idstudy=IdStudy_
       where SeriesInstanceUID=SeriesInstanceUID_; 
   end if;

   

 RAISE NOTICE '------Starting Image section---------';
  select IdImage from image
    where (sopinstanceuid = sopinstanceuid_) 
  into IdImage_;

  if (IdImage_ is null) then
   -- Inserta la imagen
   RAISE NOTICE 'idimage not found with sopinstanceuid [%]',sopinstanceuid_;
   RAISE NOTICE 'Creating new image [%]',sopinstanceuid_;
  insert into image(ImagePath,ThumbnailPath,SOPInstanceUID,IdSeries,Rows,
    Columns,FileSizeBytes,DateCreated,
    InstanceNumber, ImageType, SOPClassUID,
    AcquisitionDate, AcquisitionTime, ContentDate, ContentTime,
    AcquisitionNumber, Acr_Nema_ImagePosition,
    ImagePositionPatient, ImageOrientationPatient,
    FrameOfReferenceUID, SliceLocation,  NumberOfFrames, PatientPosition,status 
    ) 
  values(Image_, Image_||'.jpg', SOPInstanceUID_, IdSeries_, Rows_, 
    Columns_, FileSizeBytes_, current_timestamp, 
    InstanceNumber_, ImageType_, SOPClassUID_,
    AcquisitionDate_, AcquisitionTime_, ContentDate_, ContentTime_,
    AcquisitionNumber_, Acr_Nema_ImagePosition_,
    ImagePositionPatient_, ImageOrientationPatient_,
    FrameOfReferenceUID_, SliceLocation_,  NumberOfFrames_, PatientPosition_,'existing'
    );
    else
    RAISE NOTICE 'Updating image info. Idimage [%] found with sopinstanceuid [%]',IdImage_,sopinstanceuid_;
    UPDATE image
    SET ImagePath=Image_, ThumbnailPath=Image_||'.jpg',SOPInstanceUID=SOPInstanceUID_,IdSeries=IdSeries_, Rows=Rows_,
    Columns=Columns_, FileSizeBytes=FileSizeBytes_, DateCreated=current_timestamp,
    InstanceNumber=InstanceNumber_, AcquisitionTime=AcquisitionTime_,ContentDate=ContentDate_, ContentTime=ContentTime_,
    AcquisitionNumber=AcquisitionNumber_, Acr_Nema_ImagePosition=Acr_Nema_ImagePosition_,
    ImagePositionPatient=ImagePositionPatient_, ImageOrientationPatient=ImageOrientationPatient_,
    FrameOfReferenceUID=FrameOfReferenceUID_, SliceLocation=SliceLocation_,  NumberOfFrames=NumberOfFrames_, PatientPosition=PatientPosition_,status='existing'
    where sopinstanceuid = sopinstanceuid_  ; 
   end if;

  RAISE NOTICE 'Leaving PSQL procedure... ';
  FunctResult='DONE';
  RETURN FunctResult;    

  --EXCEPTION WHEN SQLSTATE '22001' THEN
  --RAISE NOTICE 'SQl error';
  
  EXCEPTION WHEN OTHERS THEN   
  begin
  RAISE NOTICE '-------SQL ERROR ---------';  
  RAISE NOTICE 'SQLState    [%],', SQLSTATE;
  RAISE NOTICE 'SQL Message [%],',SQLERRM;
  RAISE NOTICE '-------SQL ERROR ---------';
  RETURN 'ERROR '|| SQLSTATE ||' '||SQLERRM;
  end;
END;
$$;


ALTER FUNCTION public.storeimage_experimental(patientbirthdate_ date, patientbirthtime_ time without time zone, patientsex_ character varying, patientname_ character varying, patientid_ character varying, otherpatientids_ character varying, otherpatientnames_ character varying, ethnicgroup_ character varying, patientage_ character varying, patientsize_ character varying, patientweight_ character varying, occupation_ character varying, studydate_ date, studytime_ character varying, studyid_ character varying, studydescription_ character varying, institutionname_ character varying, modality_ character varying, modalityaetitle_ character varying, nameofphysiciansreadingstudy_ character varying, accessionnumber_ character varying, referringphysiciansname_ character varying, studyinstanceuid_ character varying, seriesnumber_ character varying, seriesinstanceuid_ character varying, sopinstanceuid_ character varying, seriesdate_ date, seriestime_ time without time zone, seriesdescription_ character varying, bodypartexamined_ character varying, protocolname_ character varying, operatorsname_ character varying, performingphysiciansname_ character varying, rows_ integer, columns_ integer, filesizebytes_ integer, contentlabel_ character varying, instancenumber_ character varying, imagetype_ character varying, sopclassuid_ character varying, acquisitiondate_ date, acquisitiontime_ time without time zone, contentdate_ date, contenttime_ time without time zone, acquisitionnumber_ character varying, acr_nema_imageposition_ character varying, imagepositionpatient_ character varying, imageorientationpatient_ character varying, frameofreferenceuid_ character varying, slicelocation_ character varying, numberofframes_ character varying, image_ character varying, patientposition_ character varying) OWNER TO postgres;

--
-- TOC entry 205 (class 1255 OID 69092)
-- Dependencies: 3 618
-- Name: storetasksendimage(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION storetasksendimage(patientid_ character varying, patientname_ character varying, referringphysiciansname_ character varying, performingphysiciansname_ character varying, nameofphysiciansreadingstudy_ character varying, accessionnumber_ character varying, modality_ character varying, idstudy_ character varying, idseriessel_ character varying, idsistemasexternossel_ character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  auxIdPatient_ Integer;
  auxIdStudy_ Integer;
  arrIdSeriesSel_ TEXT ARRAY;
  arrIdSistemasExternosSel_ TEXT ARRAY;
  auxCantTareas_ Integer;
BEGIN
  -- Obtengo el id del paciente
  select idpatient from patient where patientid = patientid_ into auxIdPatient_;
  -- Modifico o Inserto el paciente, según exista, o no.
  if (auxIdPatient_ is null) then
    -- Inserto un nuevo paciente
    insert into patient (patientid,patientname) values (patientid_, patientname_);
    -- Recupero el id del paciente insertado
    auxIdPatient_ = currval(pg_get_serial_sequence('patient', 'idpatient'));
  else 
    -- Modifico los datos del paciente
    update patient set patientname = patientname_ where idpatient = auxIdPatient_;
  end if;

  -- Verifico que exista el idstudy_ indicado por parámetro
  select idstudy from study where idstudy = idstudy_::Integer into auxIdStudy_;
  if (auxIdStudy_ is null) then
    RAISE EXCEPTION 'Error: el estudio id: % no existe.', idstudy_::text;
    return false;
  end if;
 
  -- Asigno el estudio al paciente indicado
  update study set idpatient = auxIdPatient_ where idstudy = idstudy_::integer;

  -- Verifico que No exista un estudio, distinto al estudio indicado por parámetro,
  -- con el AccessionNumber_ indicado por parametro.
  select idstudy from study
    where accessionnumber = accessionnumber_
          and
          idstudy <> idstudy_::integer into auxIdStudy_;
  -- Si No existe un estudio con el accessionnumber_ indicado, entonces puedo
  -- proceder con el cambio de los datos al estudio.
  if (auxIdStudy_ is null) then
    -- Modifico los datos del estudio, con los datos recibidos por parámetro
    update study set
      referringphysiciansname = referringphysiciansname_,
      performingphysiciansname = performingphysiciansname_,
      nameofphysiciansreadingstudy = nameofphysiciansreadingstudy_,
      accessionnumber = accessionnumber_,
      modality = modality_
      where idstudy = idstudy_::integer;
  else
    -- AccessionNumber ya esta siendo usado por otro Estudio.   
    -- Con 'raise exception' hace rollback las transacciones anteriores, y aborto la función.
    RAISE EXCEPTION 'El Accession Number: % ya esta referenciado por el estudio: %', accessionnumber_::text,auxIdStudy_::text;
    return false;
  end if;
 
  -- Verifico que no existan tareas de "Envio a Pacs" pendientes de ejecución,
  -- o en ejecución, para alguna de la/las series seleccionadas.
  -- Si es así, cancelo la programación de las tareas.
  EXECUTE 'select count(*) from tasksendseries'
          || ' where idseries in (' || idseriessel_ || ')'  
          || ' and excecutiondate is NULL;'
   INTO auxCantTareas_;
  -- Si hay al menos una tarea para alguna de las series, cancelo la función.
  if (auxCantTareas_ > 0) then
    RAISE EXCEPTION 'Algunas de las Series seleccionadas tienen envíos a PACS en ejecución. Por favor, espere que terminen para ejecutar otro envío.';
    return false;
  end if;

  -- Cargo las tareas de envío de las series seleccionadas, a los PACS destino
  --
  -- El parametro idseriessel_ contien las series seleccionadas,
  -- como lista de valores separados por comas.
  -- Los paso a un array para poder recorrerlos.
  -- Series para enviar
  arrIdSeriesSel_ := regexp_split_to_array(idseriessel_, ',');
  -- Sistemas Externos destinos
  -- Si el parametro idsistemasexternossel_ es NULL, indica
  -- que solo hay que hacer el cambio de header de las imagenes,
  -- pero no es necesario enviarlas a otro sistema externo.
  arrIdSistemasExternosSel_ := regexp_split_to_array(idsistemasexternossel_, ',');

  -- Ejecuta scripts sql para Cargar en una tabla las tareas pendientes de Envio de Series a PACS
  FOR x IN 1..array_length(arrIdSistemasExternosSel_, 1) LOOP
    FOR y IN 1..array_length(arrIdSeriesSel_, 1) LOOP
--      insert into tasksendseries (idseries,idexternalsystem) values (arrIdSeriesSel_[y]::integer, arrIdSistemasExternosSel_[x]::integer);

      EXECUTE 'insert into tasksendseries (idseries,idexternalsystem, state) values '
          || ' (' || arrIdSeriesSel_[y] || ',' || arrIdSistemasExternosSel_[x] || ', ''Programada'')';  
    


    END LOOP; 
  END LOOP;
 
  -- Retorno de la fución
  Return true;

END;
$$;


ALTER FUNCTION public.storetasksendimage(patientid_ character varying, patientname_ character varying, referringphysiciansname_ character varying, performingphysiciansname_ character varying, nameofphysiciansreadingstudy_ character varying, accessionnumber_ character varying, modality_ character varying, idstudy_ character varying, idseriessel_ character varying, idsistemasexternossel_ character varying) OWNER TO postgres;

--
-- TOC entry 201 (class 1255 OID 69099)
-- Dependencies: 3 618
-- Name: taskdelete(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION taskdelete(idtaskmanager_ integer, idcleaningtask_ integer, iduser_ integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
id_taskmanager_ integer;
idcleaningtask_ integer;
BEGIN

	delete from taskmanager 
	where idtaskmanager=idtaskmanager_;

	delete from taskscleaning 
	where idcleaningtask=idcleaningtask_;
			
RETURN id_taskmanager_; 
END;

$$;


ALTER FUNCTION public.taskdelete(idtaskmanager_ integer, idcleaningtask_ integer, iduser_ integer) OWNER TO postgres;

--
-- TOC entry 204 (class 1255 OID 69100)
-- Dependencies: 618 3
-- Name: tasksupdater(integer, integer, character varying, character varying, character varying, character varying, boolean, character varying, boolean, character varying, integer, integer, character varying, character varying, character varying, integer, integer, integer, boolean, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION tasksupdater(idtaskmanager_ integer, iduser_ integer, taskname_ character varying, description_ character varying, operationtype_ character varying, relatedtable_ character varying, trakingenabled_ boolean, status_ character varying, expiredtask_ boolean, executiontype_ character varying, executionhour_ integer, executionminute_ integer, executiontypehour_ character varying, executiondays_ character varying, executiontime_ character varying, amount_ integer, done_ integer, remaining_ integer, isrunning_ boolean, tagfilter_ character varying, tagvalue_ character varying, statustudy_ character varying, daysantiquity_ integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	id_taskmanager_ integer;
        lTagFilter character varying;
        lTagValue character varying;
        lStatusStudy character varying;
        lDaysAntiquity integer;

BEGIN
	id_taskmanager_=0;
	lTagFilter=tagfilter_;
	lTagValue=tagvalue_;
	lStatusStudy= statustudy_;
	lDaysAntiquity=daysantiquity_;
	
	update taskmanager 
	set executiondays=executiondays_,executiontime=executiontime_
	where idtaskmanager=idtaskmanager_;

	update taskscleaning 
	set tagfilter=lTagFilter,tagvalue=lTagValue,statusstudy=lStatusStudy,daysantiquity=lDaysAntiquity
	where idtaskmanager=idtaskmanager_;
			
RETURN id_taskmanager_; 
END;

$$;


ALTER FUNCTION public.tasksupdater(idtaskmanager_ integer, iduser_ integer, taskname_ character varying, description_ character varying, operationtype_ character varying, relatedtable_ character varying, trakingenabled_ boolean, status_ character varying, expiredtask_ boolean, executiontype_ character varying, executionhour_ integer, executionminute_ integer, executiontypehour_ character varying, executiondays_ character varying, executiontime_ character varying, amount_ integer, done_ integer, remaining_ integer, isrunning_ boolean, tagfilter_ character varying, tagvalue_ character varying, statustudy_ character varying, daysantiquity_ integer) OWNER TO postgres;

--
-- TOC entry 203 (class 1255 OID 132946)
-- Dependencies: 3 618
-- Name: test(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION test(patientname character varying, patientsex character varying) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

pn ALIAS FOR $1;
ps ALIAS FOR $2;

lpn varchar (100);
lps varchar(20);

BEGIN 
select into 
lpn,lps 
p.patientname,p.patientsex
from patient p
limit 2;

RAISE NOTICE 'NOTICE [%]',lpn; 
END;
$_$;


ALTER FUNCTION public.test(patientname character varying, patientsex character varying) OWNER TO postgres;

--
-- TOC entry 213 (class 1255 OID 132923)
-- Dependencies: 3 618
-- Name: write_routing_tasks(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION write_routing_tasks() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  changed boolean;
  r imagetosend%rowtype;
  rt routingtaskstoexecute%rowtype;
  --test
BEGIN
  --IF tg_op = 'INSERT' THEN
    for rt in 
	select 
		case 
		when rr.idaedestination::varchar is null then 'ARCHIVO'
		else 'IP'
		end as destinationtype, 
		rr.aesource,rr.destinationfolder,rr.filterattribute, rr.filtervalue, rr.idrule, es.ip, es.port, es.aetitle,
		st.minuto, st.hora, st.dia
	from routingrules rr
		left join externalsystem es on rr.idaedestination = es.idexternalsystem
		join routingschedulingtask st on st.idscheduling = rr.idscheduling
	where rr.enablerule ='TRUE' 
    LOOP
        
        if(rt.destinationtype = 'IP') then
			if(rt.filterattribute is not null) then
				for r in execute 'select i.idimage, s.idstudy, se.idseries, i.imagepath from image i join series se on se.idseries=i.idseries '||
				  'join study s on s.idstudy=se.idstudy where '||rt.filterattribute||'='''||rt.filtervalue||''' '||
				  'and i.idimage = '||new.idimage
				LOOP
					INSERT INTO routingtasks(
					idimage, idstudy, idserie, idrule, pathimage, 
					aetdest, ipaddressdest, portdest, pathdest, prestudiesnumber, 
					"minute", "hour", "day", status, creationdate)
					VALUES (r.idimage, r.idstudy, r.idseries, rt.idrule, r.imagepath, 
					rt.aetitle, rt.ip, rt.port, rt.destinationfolder, 0, 
					rt.minuto, rt.hora, rt.dia, 'programada', now());
				END LOOP;
			   else-- Entonces por aetitle	
				for r in execute 'select i.idimage, s.idstudy, se.idseries, i.imagepath from image i join series se on se.idseries=i.idseries 
				join study s on s.idstudy=se.idstudy where s.modalityaetitle ='''||rt.aesource||''' and i.idimage= '||new.idimage
				LOOP
					INSERT INTO routingtasks(
					idimage, idstudy, idserie, idrule, pathimage, 
					aetdest, ipaddressdest, portdest, pathdest, prestudiesnumber, 
					"minute", "hour", "day", status, creationdate)
					VALUES (r.idimage, r.idstudy, r.idseries, rt.idrule, r.imagepath, 
					rt.aetitle, rt.ip, rt.port, NULL, 0, 
					rt.minuto, rt.hora, rt.dia, 'programada', now());
				END LOOP;
			   end if;
	else 	 --Por Arhivo
			if(rt.filterattribute is not null) then
				for r in execute 'select i.idimage, s.idstudy, se.idseries, i.imagepath from image i join series se on se.idseries=i.idseries '||
				'join study s on s.idstudy=se.idstudy where '||rt.filterattribute||'='''||rt.filtervalue||''' '||
				'and i.idimage = '||new.idimage
				LOOP
					INSERT INTO routingtasks(
					idimage, idstudy, idserie, idrule, pathimage, 
					aetdest, ipaddressdest, portdest, pathdest, prestudiesnumber, 
					"minute", "hour", "day", status, creationdate)
					VALUES (r.idimage, r.idstudy, r.idseries, rt.idrule, r.imagepath, 
					rt.aetitle, rt.ip, rt.port,rt.destinationfolder, 0, 
					rt.minuto, rt.hora, rt.dia, 'programada', now());
				END LOOP;
			else
				--por aetitle	
				for r in execute 'select i.idimage, s.idstudy, se.idseries, i.imagepath from image i join series se on se.idseries=i.idseries 
				join study s on s.idstudy=se.idstudy where s.modalityaetitle='''||rt.aesource||'''and i.idimage = '||new.idimage
				LOOP
					INSERT INTO routingtasks(
					idimage, idstudy, idserie, idrule, pathimage, 
					aetdest, ipaddressdest, portdest, pathdest, prestudiesnumber, 
					"minute", "hour", "day", status, creationdate)
					VALUES (r.idimage, r.idstudy, r.idseries, rt.idrule, r.imagepath, 
					rt.aetitle, rt.ip, rt.port,rt.destinationfolder, 0, 
					rt.minuto, rt.hora, rt.dia, 'programada', now());
				END LOOP;
			end if;
	end if;	
    END LOOP;
   return null;
--  END IF;
END
$$;


ALTER FUNCTION public.write_routing_tasks() OWNER TO postgres;

SET default_tablespace = '';

SET default_with_oids = false;


CREATE TABLE config (
    variablename character varying(50) NOT NULL,
    variablevalue character varying(120),
    datatype character varying(50) DEFAULT 'STRING'::character varying,
    observation text,
    systemoptions boolean DEFAULT false,
    parametergroup character varying
);


ALTER TABLE public.config OWNER TO postgres;

--
-- TOC entry 155 (class 1259 OID 68946)
-- Dependencies: 1961 3
-- Name: externalsystem; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE externalsystem (
    idexternalsystem integer NOT NULL,
    name character varying(30),
    ip character varying(15),
    port integer,
    aetitle character varying(25),
    defaultsystem boolean DEFAULT false,
    external_system_type character varying(50),
    service character varying(20)
);


ALTER TABLE public.externalsystem OWNER TO postgres;

--
-- TOC entry 154 (class 1259 OID 68944)
-- Dependencies: 155 3
-- Name: externalsystem_idexternalsystem_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE externalsystem_idexternalsystem_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.externalsystem_idexternalsystem_seq OWNER TO postgres;

--
-- TOC entry 2065 (class 0 OID 0)
-- Dependencies: 154
-- Name: externalsystem_idexternalsystem_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE externalsystem_idexternalsystem_seq OWNED BY externalsystem.idexternalsystem;


--
-- TOC entry 2066 (class 0 OID 0)
-- Dependencies: 154
-- Name: externalsystem_idexternalsystem_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('externalsystem_idexternalsystem_seq', 19, true);


--
-- TOC entry 152 (class 1259 OID 68918)
-- Dependencies: 3
-- Name: image; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE image (
    idimage integer NOT NULL,
    sopinstanceuid character varying(255),
    imagepath character varying(255),
    thumbnailpath character varying(255),
    idseries integer,
    rows integer,
    columns integer,
    datecreated timestamp without time zone,
    filesizebytes integer,
    instancenumber character varying(100),
    imagetype character varying(100),
    sopclassuid character varying(100),
    acquisitiondate date,
    acquisitiontime time without time zone,
    contentdate date,
    acquisitionnumber character varying(100),
    acr_nema_imageposition character varying(100),
    contenttime time without time zone,
    imagepositionpatient character varying(100),
    imageorientationpatient character varying(100),
    frameofreferenceuid character varying(100),
    slicelocation character varying(100),
    numberofframes character varying(100),
    patientposition character varying(100),
    status character varying(100),
    windowcenter integer,
    windowwidth integer
);


ALTER TABLE public.image OWNER TO postgres;

--
-- TOC entry 151 (class 1259 OID 68916)
-- Dependencies: 152 3
-- Name: image_idimage_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE image_idimage_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.image_idimage_seq OWNER TO postgres;

--
-- TOC entry 2067 (class 0 OID 0)
-- Dependencies: 151
-- Name: image_idimage_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE image_idimage_seq OWNED BY image.idimage;


--
-- TOC entry 2068 (class 0 OID 0)
-- Dependencies: 151
-- Name: image_idimage_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('image_idimage_seq', 35893, true);


--
-- TOC entry 146 (class 1259 OID 68873)
-- Dependencies: 497 3
-- Name: study; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE study (
    idstudy integer NOT NULL,
    studydate date,
    studytime time without time zone,
    studyid character varying(20),
    studydescription character varying(255),
    modality character varying(2),
    modalityaetitle character varying(50),
    nameofphysiciansreadingstudy character varying(255),
    accessionnumber character varying(20),
    performingphysiciansname character varying(255),
    referringphysiciansname character varying(255),
    studyinstanceuid character varying(255),
    status status_,
    institutionname character varying(100),
    idpatient integer,
    created_time timestamp without time zone
);


ALTER TABLE public.study OWNER TO postgres;

--
-- TOC entry 174 (class 1259 OID 69086)
-- Dependencies: 1760 3
-- Name: institutions; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW institutions AS
    SELECT DISTINCT study.institutionname FROM study;


ALTER TABLE public.institutions OWNER TO postgres;

--
-- TOC entry 166 (class 1259 OID 69050)
-- Dependencies: 3
-- Name: keys; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE keys (
    keynumber character varying(100)
);


ALTER TABLE public.keys OWNER TO postgres;

--
-- TOC entry 173 (class 1259 OID 69082)
-- Dependencies: 1759 3
-- Name: modalityaetitles; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW modalityaetitles AS
    SELECT DISTINCT study.modalityaetitle FROM study;


ALTER TABLE public.modalityaetitles OWNER TO postgres;

--
-- TOC entry 165 (class 1259 OID 69044)
-- Dependencies: 3
-- Name: notificationrecipients; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE notificationrecipients (
    idnotificationrecipient integer NOT NULL,
    email character varying(100),
    recipientname character varying(100),
    lastnotification date
);


ALTER TABLE public.notificationrecipients OWNER TO postgres;

--
-- TOC entry 164 (class 1259 OID 69042)
-- Dependencies: 3 165
-- Name: notificationrecipients_idnotificationrecipient_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE notificationrecipients_idnotificationrecipient_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.notificationrecipients_idnotificationrecipient_seq OWNER TO postgres;

--
-- TOC entry 2069 (class 0 OID 0)
-- Dependencies: 164
-- Name: notificationrecipients_idnotificationrecipient_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE notificationrecipients_idnotificationrecipient_seq OWNED BY notificationrecipients.idnotificationrecipient;


--
-- TOC entry 2070 (class 0 OID 0)
-- Dependencies: 164
-- Name: notificationrecipients_idnotificationrecipient_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('notificationrecipients_idnotificationrecipient_seq', 1, false);


--
-- TOC entry 157 (class 1259 OID 68977)
-- Dependencies: 1963 1964 3
-- Name: pacs_user; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE pacs_user (
    id_user integer NOT NULL,
    user_name character varying(255) NOT NULL,
    password character varying(100),
    fullname character varying(255),
    administrator boolean DEFAULT false,
    email character varying(50),
    notificar boolean DEFAULT false
);


ALTER TABLE public.pacs_user OWNER TO postgres;

--
-- TOC entry 159 (class 1259 OID 68991)
-- Dependencies: 3
-- Name: pacs_user_data; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE pacs_user_data (
    id_user_data integer NOT NULL,
    nameparameter character varying(100) NOT NULL,
    valueparameter text,
    id_pacs_user integer NOT NULL,
    page_name character varying(50)
);


ALTER TABLE public.pacs_user_data OWNER TO postgres;

--
-- TOC entry 158 (class 1259 OID 68989)
-- Dependencies: 3 159
-- Name: pacs_user_data_id_user_data_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE pacs_user_data_id_user_data_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.pacs_user_data_id_user_data_seq OWNER TO postgres;

--
-- TOC entry 2071 (class 0 OID 0)
-- Dependencies: 158
-- Name: pacs_user_data_id_user_data_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE pacs_user_data_id_user_data_seq OWNED BY pacs_user_data.id_user_data;


--
-- TOC entry 2072 (class 0 OID 0)
-- Dependencies: 158
-- Name: pacs_user_data_id_user_data_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('pacs_user_data_id_user_data_seq', 5, true);


--
-- TOC entry 156 (class 1259 OID 68975)
-- Dependencies: 3 157
-- Name: pacs_user_id_user_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE pacs_user_id_user_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.pacs_user_id_user_seq OWNER TO postgres;

--
-- TOC entry 2073 (class 0 OID 0)
-- Dependencies: 156
-- Name: pacs_user_id_user_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE pacs_user_id_user_seq OWNED BY pacs_user.id_user;


--
-- TOC entry 2074 (class 0 OID 0)
-- Dependencies: 156
-- Name: pacs_user_id_user_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('pacs_user_id_user_seq', 10, true);


--
-- TOC entry 144 (class 1259 OID 68860)
-- Dependencies: 3
-- Name: patient; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE patient (
    idpatient integer NOT NULL,
    patientbirthdate date,
    patientbirthtime time without time zone,
    patientsex character varying(1),
    patientname character varying(255),
    patientid character varying(100),
    otherpatientids character varying(20),
    otherpatientnames character varying(255),
    ethnicgroup character varying(20),
    patientage character varying(20),
    patientsize character varying(20),
    patientweight character varying(20),
    occupation character varying(255)
);


ALTER TABLE public.patient OWNER TO postgres;

--
-- TOC entry 183 (class 1259 OID 132877)
-- Dependencies: 3
-- Name: patient2; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE patient2 (
    idpatient integer,
    patientbirthdate date,
    patientbirthtime time without time zone,
    patientsex character varying(1),
    patientname character varying(255),
    patientid character varying(100),
    otherpatientids character varying(20),
    otherpatientnames character varying(255),
    ethnicgroup character varying(20),
    patientage character varying(20),
    patientsize character varying(20),
    patientweight character varying(20),
    occupation character varying(255)
);


ALTER TABLE public.patient2 OWNER TO postgres;

--
-- TOC entry 148 (class 1259 OID 68891)
-- Dependencies: 3
-- Name: series; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE series (
    idseries integer NOT NULL,
    seriesnumber character varying(100),
    seriesinstanceuid character varying(255),
    seriesdate date,
    seriestime time without time zone,
    seriesdescription character varying(255),
    bodypartexamined character varying(255),
    protocolname character varying(100),
    operatorsname character varying(255),
    contentlabel character varying(255),
    idstudy integer,
    processed boolean
);


ALTER TABLE public.series OWNER TO postgres;

--
-- TOC entry 2075 (class 0 OID 0)
-- Dependencies: 148
-- Name: COLUMN series.processed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN series.processed IS 'Cuando este campo es "true" significa que la serie fue procesada por el Gateway alguna vez.';


--
-- TOC entry 179 (class 1259 OID 97396)
-- Dependencies: 1761 3
-- Name: patientStudies; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW "patientStudies" AS
    SELECT p.idpatient, p.patientid, p.patientname, p.patientbirthdate, p.patientage, p.patientweight, p.patientsex, s.idstudy, s.accessionnumber, s.modality, s.studydate, s.studydescription, (s.status)::character varying AS status, s.nameofphysiciansreadingstudy, s.referringphysiciansname, s.performingphysiciansname, count(*) AS cantimagenes FROM (((study s JOIN patient p ON ((s.idpatient = p.idpatient))) JOIN series se ON ((s.idstudy = se.idstudy))) JOIN image i ON ((se.idseries = i.idseries))) GROUP BY p.idpatient, p.patientid, p.patientname, p.patientbirthdate, p.patientage, p.patientweight, p.patientsex, s.idstudy, s.accessionnumber, s.modality, s.studydate, s.studydescription, s.status, s.nameofphysiciansreadingstudy, s.referringphysiciansname, s.performingphysiciansname;


ALTER TABLE public."patientStudies" OWNER TO postgres;

--
-- TOC entry 143 (class 1259 OID 68858)
-- Dependencies: 144 3
-- Name: patient_idpatient_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE patient_idpatient_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.patient_idpatient_seq OWNER TO postgres;

--
-- TOC entry 2076 (class 0 OID 0)
-- Dependencies: 143
-- Name: patient_idpatient_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE patient_idpatient_seq OWNED BY patient.idpatient;


--
-- TOC entry 2077 (class 0 OID 0)
-- Dependencies: 143
-- Name: patient_idpatient_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('patient_idpatient_seq', 3168, true);


--
-- TOC entry 180 (class 1259 OID 97424)
-- Dependencies: 3
-- Name: patient_patientid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE patient_patientid_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.patient_patientid_seq OWNER TO postgres;

--
-- TOC entry 2078 (class 0 OID 0)
-- Dependencies: 180
-- Name: patient_patientid_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('patient_patientid_seq', 947, true);


--
-- TOC entry 150 (class 1259 OID 68907)
-- Dependencies: 3
-- Name: replacedimages; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE replacedimages (
    idreplacedimage integer NOT NULL,
    oldimage character varying(255),
    newimage character varying(255),
    idstudy integer,
    status character varying(50),
    creationdate timestamp without time zone,
    deleteddate timestamp without time zone
);


ALTER TABLE public.replacedimages OWNER TO postgres;

--
-- TOC entry 149 (class 1259 OID 68905)
-- Dependencies: 3 150
-- Name: replacedimages_idreplacedimage_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE replacedimages_idreplacedimage_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.replacedimages_idreplacedimage_seq OWNER TO postgres;

--
-- TOC entry 2079 (class 0 OID 0)
-- Dependencies: 149
-- Name: replacedimages_idreplacedimage_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE replacedimages_idreplacedimage_seq OWNED BY replacedimages.idreplacedimage;


--
-- TOC entry 2080 (class 0 OID 0)
-- Dependencies: 149
-- Name: replacedimages_idreplacedimage_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('replacedimages_idreplacedimage_seq', 2536, true);


--
-- TOC entry 163 (class 1259 OID 69015)
-- Dependencies: 1968 3
-- Name: routingrules; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE routingrules (
    idrule integer NOT NULL,
    aesource character varying(25),
    filterattribute character varying(50),
    filtervalue character varying(50),
    idaedestination integer,
    destinationfolder character varying(150),
    deleteafter boolean,
    getpreviousstudies boolean,
    quantitypreviousstudies integer,
    prioritysequence character varying(50) DEFAULT 10,
    waittime integer,
    enablerule boolean,
    enabletask boolean,
    idscheduling integer
);


ALTER TABLE public.routingrules OWNER TO postgres;

--
-- TOC entry 162 (class 1259 OID 69013)
-- Dependencies: 3 163
-- Name: routingrules_idrule_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE routingrules_idrule_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.routingrules_idrule_seq OWNER TO postgres;

--
-- TOC entry 2081 (class 0 OID 0)
-- Dependencies: 162
-- Name: routingrules_idrule_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE routingrules_idrule_seq OWNED BY routingrules.idrule;


--
-- TOC entry 2082 (class 0 OID 0)
-- Dependencies: 162
-- Name: routingrules_idrule_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('routingrules_idrule_seq', 4, true);


--
-- TOC entry 161 (class 1259 OID 69007)
-- Dependencies: 3
-- Name: routingschedulingtask; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE routingschedulingtask (
    idscheduling integer NOT NULL,
    dia character varying(100),
    hora character varying(100),
    minuto character varying(100)
);


ALTER TABLE public.routingschedulingtask OWNER TO postgres;

--
-- TOC entry 160 (class 1259 OID 69005)
-- Dependencies: 161 3
-- Name: routingschedulingtask_idscheduling_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE routingschedulingtask_idscheduling_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.routingschedulingtask_idscheduling_seq OWNER TO postgres;

--
-- TOC entry 2083 (class 0 OID 0)
-- Dependencies: 160
-- Name: routingschedulingtask_idscheduling_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE routingschedulingtask_idscheduling_seq OWNED BY routingschedulingtask.idscheduling;


--
-- TOC entry 2084 (class 0 OID 0)
-- Dependencies: 160
-- Name: routingschedulingtask_idscheduling_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('routingschedulingtask_idscheduling_seq', 4, true);


--
-- TOC entry 176 (class 1259 OID 77305)
-- Dependencies: 1977 1978 1979 1980 1981 3
-- Name: routingtasks; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE routingtasks (
    idroutingtask integer NOT NULL,
    idimage integer NOT NULL,
    idstudy integer NOT NULL,
    idserie integer NOT NULL,
    idrule integer NOT NULL,
    pathimage character varying(150),
    aetdest character varying(50),
    ipaddressdest character varying(50),
    portdest integer,
    pathdest character varying(255),
    prestudiesnumber integer DEFAULT 0,
    minute character varying(50),
    hour character varying(50),
    day character varying(50),
    status character varying(100) DEFAULT 'programada'::character varying(100),
    creationdate timestamp without time zone DEFAULT now(),
    starteddate timestamp without time zone,
    finisheddate timestamp without time zone,
    intentos numeric DEFAULT 0,
    tracked boolean DEFAULT false
);


ALTER TABLE public.routingtasks OWNER TO postgres;

--
-- TOC entry 175 (class 1259 OID 77303)
-- Dependencies: 176 3
-- Name: routingtasks_idroutingtask_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE routingtasks_idroutingtask_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.routingtasks_idroutingtask_seq OWNER TO postgres;

--
-- TOC entry 2085 (class 0 OID 0)
-- Dependencies: 175
-- Name: routingtasks_idroutingtask_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE routingtasks_idroutingtask_seq OWNED BY routingtasks.idroutingtask;


--
-- TOC entry 2086 (class 0 OID 0)
-- Dependencies: 175
-- Name: routingtasks_idroutingtask_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('routingtasks_idroutingtask_seq', 37776, true);



--
-- TOC entry 172 (class 1259 OID 69077)
-- Dependencies: 1758 3
-- Name: serieImages; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW "serieImages" AS
    SELECT s.idseries, s.seriesnumber, s.seriesinstanceuid, s.seriesdate, s.seriestime, s.seriesdescription, s.bodypartexamined, s.protocolname, s.operatorsname, s.contentlabel, s.idstudy, count(s.idseries) AS cantimages FROM (series s JOIN image i ON ((i.idseries = s.idseries))) GROUP BY s.idseries, s.seriesnumber, s.seriesinstanceuid, s.seriesdate, s.seriestime, s.seriesdescription, s.bodypartexamined, s.protocolname, s.operatorsname, s.contentlabel, s.idstudy;


ALTER TABLE public."serieImages" OWNER TO postgres;

--
-- TOC entry 147 (class 1259 OID 68889)
-- Dependencies: 148 3
-- Name: series_idseries_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE series_idseries_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.series_idseries_seq OWNER TO postgres;

--
-- TOC entry 2088 (class 0 OID 0)
-- Dependencies: 147
-- Name: series_idseries_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE series_idseries_seq OWNED BY series.idseries;


--
-- TOC entry 2089 (class 0 OID 0)
-- Dependencies: 147
-- Name: series_idseries_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('series_idseries_seq', 5400, true);


--
-- TOC entry 145 (class 1259 OID 68871)
-- Dependencies: 146 3
-- Name: study_idstudy_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE study_idstudy_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.study_idstudy_seq OWNER TO postgres;

--
-- TOC entry 2090 (class 0 OID 0)
-- Dependencies: 145
-- Name: study_idstudy_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE study_idstudy_seq OWNED BY study.idstudy;


--
-- TOC entry 2091 (class 0 OID 0)
-- Dependencies: 145
-- Name: study_idstudy_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('study_idstudy_seq', 2943, true);


--
-- TOC entry 171 (class 1259 OID 69068)
-- Dependencies: 1975 3
-- Name: taskcleaning_log; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE taskcleaning_log (
    idcleaningtask integer NOT NULL,
    idimage integer NOT NULL,
    log_text character varying(100),
    creationdate timestamp without time zone DEFAULT now()
);


ALTER TABLE public.taskcleaning_log OWNER TO postgres;

--
-- TOC entry 170 (class 1259 OID 69061)
-- Dependencies: 1972 1973 1974 3
-- Name: taskmanager; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE taskmanager (
    idtaskmanager integer NOT NULL,
    iduser integer NOT NULL,
    taskname character varying(50),
    description character varying(50),
    operationtype character varying(50),
    relatedtable character varying(50),
    trakingenabled boolean DEFAULT false,
    status character varying(7),
    expiredtask boolean DEFAULT false,
    executiontype character varying(50),
    executionhour integer,
    executionminute integer,
    executiontypehour character varying(50),
    executiondays character varying(7),
    executiontime character varying(15),
    amount integer,
    done integer,
    remaining integer,
    isrunning boolean DEFAULT false
);


ALTER TABLE public.taskmanager OWNER TO postgres;

--
-- TOC entry 169 (class 1259 OID 69059)
-- Dependencies: 3 170
-- Name: taskmanager_idtaskmanager_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE taskmanager_idtaskmanager_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.taskmanager_idtaskmanager_seq OWNER TO postgres;

--
-- TOC entry 2092 (class 0 OID 0)
-- Dependencies: 169
-- Name: taskmanager_idtaskmanager_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE taskmanager_idtaskmanager_seq OWNED BY taskmanager.idtaskmanager;


--
-- TOC entry 2093 (class 0 OID 0)
-- Dependencies: 169
-- Name: taskmanager_idtaskmanager_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('taskmanager_idtaskmanager_seq', 12, true);


--
-- TOC entry 168 (class 1259 OID 69055)
-- Dependencies: 3
-- Name: taskscleaning; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE taskscleaning (
    idcleaningtask integer NOT NULL,
    idtaskmanager integer NOT NULL,
    tagfilter character varying(75),
    tagvalue character varying(50),
    statusstudy character varying(50),
    daysantiquity integer
);


ALTER TABLE public.taskscleaning OWNER TO postgres;

--
-- TOC entry 167 (class 1259 OID 69053)
-- Dependencies: 168 3
-- Name: taskscleaning_idcleaningtask_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE taskscleaning_idcleaningtask_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.taskscleaning_idcleaningtask_seq OWNER TO postgres;

--
-- TOC entry 2094 (class 0 OID 0)
-- Dependencies: 167
-- Name: taskscleaning_idcleaningtask_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE taskscleaning_idcleaningtask_seq OWNED BY taskscleaning.idcleaningtask;


--
-- TOC entry 2095 (class 0 OID 0)
-- Dependencies: 167
-- Name: taskscleaning_idcleaningtask_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('taskscleaning_idcleaningtask_seq', 12, true);


--
-- TOC entry 178 (class 1259 OID 97329)
-- Dependencies: 1983 3
-- Name: tasksendseries; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE tasksendseries (
    idtask integer NOT NULL,
    createddate timestamp without time zone DEFAULT now(),
    excecutiondate timestamp without time zone,
    state character varying(15),
    idseries integer,
    idexternalsystem integer,
    log text
);


ALTER TABLE public.tasksendseries OWNER TO postgres;

--
-- TOC entry 177 (class 1259 OID 97327)
-- Dependencies: 178 3
-- Name: tasksendseries_idtask_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE tasksendseries_idtask_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.tasksendseries_idtask_seq OWNER TO postgres;

--
-- TOC entry 2096 (class 0 OID 0)
-- Dependencies: 177
-- Name: tasksendseries_idtask_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE tasksendseries_idtask_seq OWNED BY tasksendseries.idtask;


--
-- TOC entry 2097 (class 0 OID 0)
-- Dependencies: 177
-- Name: tasksendseries_idtask_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('tasksendseries_idtask_seq', 7, true);


--
-- TOC entry 182 (class 1259 OID 124675)
-- Dependencies: 1984 3
-- Name: test; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE test (
    freegblimit character varying(50) DEFAULT '5'::character varying
);


ALTER TABLE public.test OWNER TO postgres;

--
-- TOC entry 184 (class 1259 OID 132903)
-- Dependencies: 3
-- Name: testinsert; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE testinsert (
    test character varying(100)
);


ALTER TABLE public.testinsert OWNER TO postgres;


-- TOC entry 1960 (class 2604 OID 68949)
-- Dependencies: 154 155 155
-- Name: idexternalsystem; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY externalsystem ALTER COLUMN idexternalsystem SET DEFAULT nextval('externalsystem_idexternalsystem_seq'::regclass);


--
-- TOC entry 1957 (class 2604 OID 68921)
-- Dependencies: 152 151 152
-- Name: idimage; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY image ALTER COLUMN idimage SET DEFAULT nextval('image_idimage_seq'::regclass);


--
-- TOC entry 1969 (class 2604 OID 69047)
-- Dependencies: 165 164 165
-- Name: idnotificationrecipient; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY notificationrecipients ALTER COLUMN idnotificationrecipient SET DEFAULT nextval('notificationrecipients_idnotificationrecipient_seq'::regclass);


--
-- TOC entry 1962 (class 2604 OID 68980)
-- Dependencies: 156 157 157
-- Name: id_user; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY pacs_user ALTER COLUMN id_user SET DEFAULT nextval('pacs_user_id_user_seq'::regclass);


--
-- TOC entry 1965 (class 2604 OID 68994)
-- Dependencies: 158 159 159
-- Name: id_user_data; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY pacs_user_data ALTER COLUMN id_user_data SET DEFAULT nextval('pacs_user_data_id_user_data_seq'::regclass);


--
-- TOC entry 1953 (class 2604 OID 68863)
-- Dependencies: 144 143 144
-- Name: idpatient; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY patient ALTER COLUMN idpatient SET DEFAULT nextval('patient_idpatient_seq'::regclass);


--
-- TOC entry 1956 (class 2604 OID 68910)
-- Dependencies: 150 149 150
-- Name: idreplacedimage; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY replacedimages ALTER COLUMN idreplacedimage SET DEFAULT nextval('replacedimages_idreplacedimage_seq'::regclass);


--
-- TOC entry 1967 (class 2604 OID 69018)
-- Dependencies: 162 163 163
-- Name: idrule; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY routingrules ALTER COLUMN idrule SET DEFAULT nextval('routingrules_idrule_seq'::regclass);


--
-- TOC entry 1966 (class 2604 OID 69010)
-- Dependencies: 160 161 161
-- Name: idscheduling; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY routingschedulingtask ALTER COLUMN idscheduling SET DEFAULT nextval('routingschedulingtask_idscheduling_seq'::regclass);


--
-- TOC entry 1976 (class 2604 OID 77308)
-- Dependencies: 176 175 176
-- Name: idroutingtask; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY routingtasks ALTER COLUMN idroutingtask SET DEFAULT nextval('routingtasks_idroutingtask_seq'::regclass);


--
-- TOC entry 1955 (class 2604 OID 68894)
-- Dependencies: 147 148 148
-- Name: idseries; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY series ALTER COLUMN idseries SET DEFAULT nextval('series_idseries_seq'::regclass);


--
-- TOC entry 1954 (class 2604 OID 68876)
-- Dependencies: 145 146 146
-- Name: idstudy; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY study ALTER COLUMN idstudy SET DEFAULT nextval('study_idstudy_seq'::regclass);


--
-- TOC entry 1971 (class 2604 OID 69064)
-- Dependencies: 170 169 170
-- Name: idtaskmanager; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY taskmanager ALTER COLUMN idtaskmanager SET DEFAULT nextval('taskmanager_idtaskmanager_seq'::regclass);


--
-- TOC entry 1970 (class 2604 OID 69058)
-- Dependencies: 167 168 168
-- Name: idcleaningtask; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY taskscleaning ALTER COLUMN idcleaningtask SET DEFAULT nextval('taskscleaning_idcleaningtask_seq'::regclass);


--
-- TOC entry 1982 (class 2604 OID 97332)
-- Dependencies: 177 178 178
-- Name: idtask; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY tasksendseries ALTER COLUMN idtask SET DEFAULT nextval('tasksendseries_idtask_seq'::regclass);


--
-- TOC entry 1986 (class 2604 OID 141175)
-- Dependencies: 187 186 187
-- Name: orden; Type: DEFAULT; Schema: public; Owner: postgres
--


SET search_path = public, pg_catalog;

--
-- TOC entry 2006 (class 2606 OID 68943)
-- Dependencies: 153 153
-- Name: config_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY config
    ADD CONSTRAINT config_pkey PRIMARY KEY (variablename);


--
-- TOC entry 2020 (class 2606 OID 69049)
-- Dependencies: 165 165
-- Name: emailrecipient_PK; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY notificationrecipients
    ADD CONSTRAINT "emailrecipient_PK" PRIMARY KEY (idnotificationrecipient);


--
-- TOC entry 2008 (class 2606 OID 68952)
-- Dependencies: 155 155
-- Name: externalsystem_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY externalsystem
    ADD CONSTRAINT externalsystem_pkey PRIMARY KEY (idexternalsystem);


--
-- TOC entry 2002 (class 2606 OID 68926)
-- Dependencies: 152 152
-- Name: image_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY image
    ADD CONSTRAINT image_pkey PRIMARY KEY (idimage);


--
-- TOC entry 2004 (class 2606 OID 68928)
-- Dependencies: 152 152
-- Name: image_sopinstanceuid_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY image
    ADD CONSTRAINT image_sopinstanceuid_key UNIQUE (sopinstanceuid);


--
-- TOC entry 2014 (class 2606 OID 68999)
-- Dependencies: 159 159
-- Name: pacs_user_data_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY pacs_user_data
    ADD CONSTRAINT pacs_user_data_pkey PRIMARY KEY (id_user_data);


--
-- TOC entry 2010 (class 2606 OID 68986)
-- Dependencies: 157 157
-- Name: pacs_user_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY pacs_user
    ADD CONSTRAINT pacs_user_pkey PRIMARY KEY (id_user);


--
-- TOC entry 1990 (class 2606 OID 97387)
-- Dependencies: 144 144
-- Name: patient_patientid_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY patient
    ADD CONSTRAINT patient_patientid_key UNIQUE (patientid);


--
-- TOC entry 1992 (class 2606 OID 68868)
-- Dependencies: 144 144
-- Name: patient_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY patient
    ADD CONSTRAINT patient_pkey PRIMARY KEY (idpatient);


--
-- TOC entry 2000 (class 2606 OID 68915)
-- Dependencies: 150 150
-- Name: replacedimages_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY replacedimages
    ADD CONSTRAINT replacedimages_pkey PRIMARY KEY (idreplacedimage);


--
-- TOC entry 2018 (class 2606 OID 69021)
-- Dependencies: 163 163
-- Name: routingrules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY routingrules
    ADD CONSTRAINT routingrules_pkey PRIMARY KEY (idrule);


--
-- TOC entry 2016 (class 2606 OID 69012)
-- Dependencies: 161 161
-- Name: routingschedulingtask_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY routingschedulingtask
    ADD CONSTRAINT routingschedulingtask_pkey PRIMARY KEY (idscheduling);


--
-- TOC entry 2022 (class 2606 OID 77317)
-- Dependencies: 176 176
-- Name: routingtasks_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY routingtasks
    ADD CONSTRAINT routingtasks_pkey PRIMARY KEY (idroutingtask);


--
-- TOC entry 1998 (class 2606 OID 68899)
-- Dependencies: 148 148
-- Name: series_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY series
    ADD CONSTRAINT series_pkey PRIMARY KEY (idseries);


--
-- TOC entry 1994 (class 2606 OID 68881)
-- Dependencies: 146 146
-- Name: study_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY study
    ADD CONSTRAINT study_pkey PRIMARY KEY (idstudy);


--
-- TOC entry 1996 (class 2606 OID 68883)
-- Dependencies: 146 146
-- Name: study_studyinstanceuid_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY study
    ADD CONSTRAINT study_studyinstanceuid_key UNIQUE (studyinstanceuid);


--
-- TOC entry 2024 (class 2606 OID 97338)
-- Dependencies: 178 178
-- Name: tasksendseries_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tasksendseries
    ADD CONSTRAINT tasksendseries_pkey PRIMARY KEY (idtask);


--
-- TOC entry 2012 (class 2606 OID 68988)
-- Dependencies: 157 157
-- Name: user_name_key_unique; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY pacs_user
    ADD CONSTRAINT user_name_key_unique UNIQUE (user_name);


--
-- TOC entry 2036 (class 2620 OID 132924)
-- Dependencies: 213 152
-- Name: tr_write_routing_tasks; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER tr_write_routing_tasks
    AFTER INSERT OR UPDATE ON image
    FOR EACH ROW
    EXECUTE PROCEDURE write_routing_tasks();


--
-- TOC entry 2031 (class 2606 OID 68929)
-- Dependencies: 152 1997 148
-- Name: image_idseries_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY image
    ADD CONSTRAINT image_idseries_fkey FOREIGN KEY (idseries) REFERENCES series(idseries);


--
-- TOC entry 2032 (class 2606 OID 69000)
-- Dependencies: 2009 157 159
-- Name: pacs_user_data_id_pacs_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY pacs_user_data
    ADD CONSTRAINT pacs_user_data_id_pacs_user_fkey FOREIGN KEY (id_pacs_user) REFERENCES pacs_user(id_user);


--
-- TOC entry 2033 (class 2606 OID 69022)
-- Dependencies: 2015 161 163
-- Name: routingrules_idscheduling_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY routingrules
    ADD CONSTRAINT routingrules_idscheduling_fkey FOREIGN KEY (idscheduling) REFERENCES routingschedulingtask(idscheduling);


--
-- TOC entry 2030 (class 2606 OID 68900)
-- Dependencies: 148 1993 146
-- Name: series_idstudy_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY series
    ADD CONSTRAINT series_idstudy_fkey FOREIGN KEY (idstudy) REFERENCES study(idstudy);


--
-- TOC entry 2029 (class 2606 OID 68884)
-- Dependencies: 146 144 1991
-- Name: study_idpatient_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY study
    ADD CONSTRAINT study_idpatient_fkey FOREIGN KEY (idpatient) REFERENCES patient(idpatient);


--
-- TOC entry 2034 (class 2606 OID 97339)
-- Dependencies: 178 2007 155
-- Name: tasksendseries_idexternalsystem_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY tasksendseries
    ADD CONSTRAINT tasksendseries_idexternalsystem_fkey FOREIGN KEY (idexternalsystem) REFERENCES externalsystem(idexternalsystem);


--
-- TOC entry 2035 (class 2606 OID 97344)
-- Dependencies: 1997 178 148
-- Name: tasksendseries_idseries_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY tasksendseries
    ADD CONSTRAINT tasksendseries_idseries_fkey FOREIGN KEY (idseries) REFERENCES series(idseries);


--
-- TOC entry 2064 (class 0 OID 0)
-- Dependencies: 3
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;


-- Completed on 2013-03-27 15:47:42 ART

--
-- PostgreSQL database dump complete
--

